package hub.list;

import java.util.HashMap;

/**
 * @author hub
 *
 * @date 2021/8/22
 * @description HashMap的test
 */
public class HashMapHub {
    /**
     * 在Java中，HashMap的实现采用了（数组 + 链表 + 红黑树）的复杂结构，数组的一个元素又称作桶。
     *
     * 在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，
     * 如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。
     *
     * 当一个链表的元素个数达到一定的数量（且数组的长度达到一定的长度）后，则把链表转化为红黑树，从而提高效率。
     * 且数组的长度达到一定的长度: 树化，当容量达到64且链表的长度达到8时进行树化，当链表的长度小于6时反树化。
     *
     * 数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，
     * 所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。
     *
     */


    /**
     * hashMap扩容
     *
     * （1）如果使用是默认构造方法，则第一次插入元素时初始化为默认值，容量为16，扩容门槛为12；
     *
     * （2）如果使用的是非默认构造方法，则第一次插入元素时初始化容量等于扩容门槛，
     * 扩容门槛在构造方法里等于传入容量向上最近的2的n次方；
     *
     * （3）如果旧容量大于0，则新容量等于旧容量的2倍，但不超过最大容量2的30次方，新扩容门槛为旧扩容门槛的2倍；
     *
     * （4）创建一个新容量的桶；
     *
     * （5）搬移元素，原链表分化成两个链表，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置；
     *
     */

    /**
     * 总结：
     *
     * （1）HashMap是一种散列表，采用（数组 + 链表 + 红黑树）的存储结构；
     *
     * （2）HashMap的默认初始容量为16（1<<4），默认装载因子为0.75f，容量总是2的n次方；
     *
     * （3）HashMap扩容时每次容量变为原来的两倍；
     *
     * （4）当桶的数量小于64时不会进行树化，只会扩容；
     *
     * （5）当桶的数量大于64且单个桶中元素的数量大于8时，进行树化；
     *
     * （6）当单个桶中元素数量小于6时，进行反树化；
     *
     * （7）HashMap是非线程安全的容器；
     *
     * （8）HashMap查找添加元素的时间复杂度都为O(1)；
     *
     */

    /**
     * 红黑树知多少？
     *
     * 红黑树具有以下5种性质：
     *
     * （1）节点是红色或黑色。
     *
     * （2）根节点是黑色。
     *
     * （3）每个叶节点（NIL节点，空节点）是黑色的。
     *
     * （4）每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
     *
     * （5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
     *
     * 红黑树的时间复杂度为O(log n)，与树的高度成正比。
     *
     * 红黑树每次的插入、删除操作都需要做平衡，平衡时有可能会改变根节点的位置，颜色转换，左旋，右旋等。
     */

    public static void main(String[] args) {
        HashMap<Integer, String> hashMap = new HashMap<>();
    }
}
